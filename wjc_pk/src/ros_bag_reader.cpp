#include <iostream>
#include <typeinfo>

#include "ros/ros.h"
#include <rosbag/bag.h>
#include <rosbag/view.h>

#include <std_msgs/Int32.h>
#include <std_msgs/String.h>
#include <wjc_pk/CustomMsg.h>
#include <wjc_pk/CustomPoint.h>

#include <boost/foreach.hpp>
#define foreach BOOST_FOREACH

int main(int argc, char **argv)
{
    /*initalize the node*/
    ros::init(argc, argv, "writer_example");
    ros::NodeHandle n;
      
    /*get parameter from .launch. the rosbag path  ----need repair this paragraph*/
    /*std::string custom_bag_path;
    double parking_x;
    
    ros::param::get("custom_bag_path",custom_bag_path);
    ros::param::get("parking_x",parking_x);

    std::cout<<"input path:"<<custom_bag_path<<" "<<parking_x<<std::endl;*/
    
    //打开bag文件
    rosbag::Bag bag;
    bag.open("crc_short.bag", rosbag::bagmode::Read);

    //设置需要遍历的topic
    std::vector<std::string> topics; 
    topics.push_back(std::string("/livox/lidar"));
    topics.push_back(std::string("chatter"));
    topics.push_back(std::string("numbers"));

    rosbag::View view(bag, rosbag::TopicQuery(topics));
    //rosbag::View view_all(view); //读取全部topic
    //使用迭代器的方式遍历,注意：每一个迭代器为一帧数据
    rosbag::View::iterator it = view.begin();

    int count_k;
    count_k = 0;

    for(; it != view.end(); ++it){
        //std::cout<<"----------------------------------"<<std::endl; /*each line represents a new scan part*/
        auto m = *it;
        //得到该帧数据的topic
        std::string topic = m.getTopic();

        /*For bag created by writer_example.cpp*/
        if(topic == "chatter"){
        	//此处为消息头文件中的ConstPtr
            std_msgs::String::ConstPtr msgPtr = m.instantiate<std_msgs::String>();
            if(msgPtr != NULL){
	            std_msgs::String  msg = *msgPtr;
                std::cout<<"chatter: "<<msg<<std::endl;
            }
        }
        if(topic == "numbers"){
            std_msgs::Int32::ConstPtr msgPtr = m.instantiate<std_msgs::Int32>();
            if(msgPtr != NULL){
	            std_msgs::Int32  msg = *msgPtr;
                std::cout<<"numbers: "<<msg<<std::endl;
            }
        }

        /*For bag generated by lidar*/
        /* format of CustomMsg
        # Livox publish pointcloud msg format.
        Header header             # ROS standard message header
        uint64 timebase           # The time of first point
        uint32 point_num          # Total number of pointclouds
        uint8  lidar_id           # Lidar device id number
        uint8[3]  rsvd            # Reserved use
        CustomPoint[] points      # Pointcloud data
        */

        if(topic == "/livox/lidar"){
            wjc_pk::CustomMsg::ConstPtr CustomMsg_Ptr = m.instantiate<wjc_pk::CustomMsg>();
            if(CustomMsg_Ptr!= NULL){
                count_k++;
                if(count_k<=3){/*a number limitation of records for debug*/
                    /*output CustomMsg info*/
                    std::cout<<"Header: "<< CustomMsg_Ptr->header.frame_id
                    <<" Time stamp:"<<CustomMsg_Ptr->header.stamp<<std::endl;
                    std::cout<<"time:"<<CustomMsg_Ptr->timebase<<" point number:"<<CustomMsg_Ptr->point_num<<" LiDAR ID:"<<CustomMsg_Ptr->lidar_id<<std::endl;
                    
                    /*output vector of pointcloud*/
                    //std::cout<<"vector type:"<<typeid(CustomMsg_Ptr->points).name()<<" point type"<<typeid(CustomMsg_Ptr->points[24000-1]).name()<<std::endl; //print data type of point cloud vector and point cloud.
                    std::cout<<CustomMsg_Ptr->points.size()<<" ";
                    std::cout<<CustomMsg_Ptr->points[24000-1]<<std::endl; //number of pointclou in each vector is included in the previous info
                
                    /*marker template segmentation code*/

                }
            }
        }
    }
    std::cout<<"count"<<count_k<<std::endl;
    bag.close();
}
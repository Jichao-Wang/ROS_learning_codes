#include <iostream>
#include <typeinfo>
#include <vector>
#include <math.h>
#include <algorithm>
#include <typeinfo>

#include "ros/ros.h"
#include <rosbag/bag.h>
#include <rosbag/view.h>

#include <std_msgs/Int32.h>
#include <std_msgs/String.h>
#include <sensor_msgs/PointCloud2.h>
#include <sensor_msgs/Image.h>
#include <wjc_pk/CustomMsg.h>
#include <wjc_pk/CustomPoint.h>

#include <pcl/io/pcd_io.h>
#include <pcl/point_types.h>
#include <pcl/surface/3rdparty/poisson4/geometry.h>
#include <pcl_conversions/pcl_conversions.h>
#include <pcl/sample_consensus/sac_model_circle3d.h>
#include <pcl/sample_consensus/ransac.h>
#include <pcl/segmentation/progressive_morphological_filter.h>

#include <cv_bridge/cv_bridge.h>
#include <opencv2/opencv.hpp>

#include <boost/foreach.hpp>

#include "../include/abc.h"

#define foreach BOOST_FOREACH
#define Pi acos(-1)
#define livox_line_number 6 /*index of them are 0-5*/

void CustomMsg_interpreter(wjc_pk::CustomMsg::ConstPtr &CustomMsg_Ptr)
{
    /*display messages of a bag generated by lidar*/
    /*format of CustomMsg
    # Livox publish pointcloud msg format.
    Header header             # ROS standard message header
    uint64 timebase           # The time of first point
    uint32 point_num          # Total number of pointclouds
    uint8  lidar_id           # Lidar device id number
    uint8[3]  rsvd            # Reserved use
    CustomPoint[] points      # Pointcloud data
    */
    if (CustomMsg_Ptr != NULL)
    {
        /*output CustomMsg info*/
        std::cout << "Header: " << CustomMsg_Ptr->header.frame_id << "\n"
                  << "Header Timestamp: " << CustomMsg_Ptr->header.stamp << "\n"
                  << "timebase: " << CustomMsg_Ptr->timebase << "\n"
                  << "point number: " << CustomMsg_Ptr->point_num << "\n"
                  << "LiDAR ID: " << CustomMsg_Ptr->lidar_id << std::endl;

        /*output vector of pointcloud*/
        //std::cout<<"vector type:"<<typeid(CustomMsg_Ptr->points).name()<<" point type"<<typeid(CustomMsg_Ptr->points[24000-1]).name()<<std::endl; //print data type of point cloud vector and point cloud.
        std::cout << "point vector size: " << CustomMsg_Ptr->points.size() << "\n\n";
        for (int i = 0; i <= 1; i++)
        {
            // ******it should be i<CustomMsg_Ptr->points.size()
            std::cout << CustomMsg_Ptr->points[i] << std::endl; //number of pointcloud in each vector is included in the previous info
        }
        std::cout << CustomMsg_Ptr->points[24000 - 1] << std::endl; //number of pointcloud in each vector is included in the previous info
        //std::cout<<CustomMsg_Ptr->points[0].x;  // the other method to display coordinate
    }
    else
    {
        std::cout << "empty pointer" << std::endl;
    }
}

void Custom_Msg2pcl_cloud(wjc_pk::CustomMsg::ConstPtr &CustomMsg_Ptr, pcl::PointCloud<pcl::PointXYZI> &pcl_cloud)
{
    pcl_cloud.points.resize(0);
    for (int i = 0; i < CustomMsg_Ptr->points.size(); i++)
    {
        /*dropout error points*/
        if (CustomMsg_Ptr->points[i].x - 0 >= 0.00001 && CustomMsg_Ptr->points[i].y - 0 <= 0.00001)
            continue;
        /*copy to pcl format*/
        pcl::PointXYZI mid_point;
        mid_point.x = CustomMsg_Ptr->points[i].x;
        mid_point.y = CustomMsg_Ptr->points[i].y;
        mid_point.z = CustomMsg_Ptr->points[i].z;
        mid_point.intensity = CustomMsg_Ptr->points[i].reflectivity;
        pcl_cloud.push_back(mid_point);
    }
    //std::cout<<"Custom_cloud:\n"<<CustomMsg_Ptr->points[0]<<"\n";
    //std::cout<<"pcl_cloud:"<<pcl_cloud.points[0]<<"\n";
    //std::cout<<pcl_cloud.points.size()<<std::endl;
}

Eigen::VectorXf detect_3d_circle(pcl::PointCloud<pcl::PointXYZI>::Ptr pcl_cloud)
{
    Eigen::VectorXf modelParas;
    /*3D circle extraction*/
    std::vector<int> inliersCircle3D;
    pcl::SampleConsensusModelCircle3D<pcl::PointXYZI>::Ptr model_circle3D(new pcl::SampleConsensusModelCircle3D<pcl::PointXYZI>(pcl_cloud));
    model_circle3D->setRadiusLimits(0.065, 0.07); /*contraint of radius*/
    pcl::RandomSampleConsensus<pcl::PointXYZI> ransac(model_circle3D);
    /*contraint of thickness*/
    ransac.setDistanceThreshold(.01);
    //ransac.setDistanceThreshold(.05);
    ransac.computeModel();
    ransac.getInliers(inliersCircle3D);
    ransac.getModelCoefficients(modelParas);
    //std::cout<<modelParas[3]<<" ";
    return modelParas;
}

pcl::PointCloud<pcl::PointXYZI>::Ptr draw_circle_template(Eigen::VectorXf modelParas)
{
    //std::cout <<"center x,y,z; R; vector\n"<<modelParas<< "\n";
    pcl::PointXYZ planeNormal(modelParas[0], modelParas[1], modelParas[2]);
    double R = modelParas[3];
    pcl::PointXYZ centerPoint(modelParas[4], modelParas[5], modelParas[6]);

    double nx = planeNormal.x, ny = planeNormal.y, nz = planeNormal.z;
    double cx = centerPoint.x, cy = centerPoint.y, cz = centerPoint.z;
    double r = R;

    double ux = ny, uy = -nx, uz = 0;
    double vx = nx * nz,
           vy = ny * nz,
           vz = -nx * nx - ny * ny;

    double sqrtU = sqrt(ux * ux + uy * uy + uz * uz);
    double sqrtV = sqrt(vx * vx + vy * vy + vz * vz);

    double ux_ = (1 / sqrtU) * ux;
    double uy_ = (1 / sqrtU) * uy;
    double uz_ = (1 / sqrtU) * uz;

    double vx_ = (1 / sqrtV) * vx;
    double vy_ = (1 / sqrtV) * vy;
    double vz_ = (1 / sqrtV) * vz;

    double xi, yi, zi;
    double t = 0;
    double angle = (t / 180.0) * Pi;
    vector<double> x;
    vector<double> y;
    vector<double> z;

    while (t < 360.0)
    {
        xi = cx + r * (ux_ * cos(angle) + vx_ * sin(angle));
        yi = cy + r * (uy_ * cos(angle) + vy_ * sin(angle));
        zi = cz + r * (uz_ * cos(angle) + vz_ * sin(angle));
        x.push_back(xi);
        y.push_back(yi);
        z.push_back(zi);

        t = t + 1;
        angle = (t / 180.0) * Pi;
    }
    pcl::PointCloud<pcl::PointXYZI>::Ptr theroyCirclePoints(new pcl::PointCloud<pcl::PointXYZI>);

    theroyCirclePoints->resize(x.size());
    for (int i = 0; i < x.size(); i++)
    {
        (*theroyCirclePoints)[i].x = x[i];
        (*theroyCirclePoints)[i].y = y[i];
        (*theroyCirclePoints)[i].z = z[i];
        (*theroyCirclePoints)[i].intensity = 255;
    }
    return theroyCirclePoints;
}

pcl::PointCloud<pcl::PointXYZI> difference_pcl_cloud(wjc_pk::CustomMsg::ConstPtr &CustomMsg_Ptr)
{
    pcl::PointCloud<pcl::PointXYZI> dif_pcl_cloud;
    if (CustomMsg_Ptr != NULL)
    {
        for (int i = 0; i < CustomMsg_Ptr->points.size() - 1; i++)
        {
            //if (CustomMsg_Ptr->points[i].line==0){
            pcl::PointXYZI mid;
            mid.x = CustomMsg_Ptr->points[i].x;
            mid.y = CustomMsg_Ptr->points[i].y;
            mid.z = CustomMsg_Ptr->points[i].z;
            mid.intensity = CustomMsg_Ptr->points[i + 1].reflectivity - CustomMsg_Ptr->points[i].reflectivity;
            //std::cout<<mid.intensity<<" ";
            /*find edge points.*/
            if (abs(mid.intensity) >= 20)
                dif_pcl_cloud.push_back(mid);
            //}
        }
    }
    else
    {
        std::cout << "empty pointer" << std::endl;
    }
    return dif_pcl_cloud;
}

int main(int argc, char **argv)
{
    /*initialize the node*/
    ros::init(argc, argv, "writer_example");
    ros::NodeHandle n;
    ros::Publisher pcl_pub = n.advertise<sensor_msgs::PointCloud2>("wjc_pcl_output", 100);
    ros::Publisher marker_pub = n.advertise<sensor_msgs::PointCloud2>("wjc_marker", 100);
    ros::Publisher dif_1_pub = n.advertise<sensor_msgs::PointCloud2>("difference_1", 100);

    /*打开bag文件*/
    rosbag::Bag bag;
    bag.open("data/crc_short2.bag", rosbag::bagmode::Read); //"Test2crc.bag"

    /*设置需要遍历的topic*/
    std::vector<std::string> topics;
    //topics.push_back(std::string("/livox/lidar"));
    topics.push_back(std::string("/camera/color/image_raw"));
    //topics.push_back(std::string("chatter"));
    //topics.push_back(std::string("numbers"));

    rosbag::View view(bag, rosbag::TopicQuery(topics));
    //rosbag::View view_all(view); //读取全部topic
    //使用迭代器的方式遍历,注意：每一个迭代器为一帧数据
    rosbag::View::iterator it = view.begin();

    int frames = 0;
    ros::Rate loop_rate(10);
    while (ros::ok())
    {
        for (; it != view.end(); ++it)
        {
            //std::cout<<"----------------------------------"<<std::endl; /*each line represents a new scan part*/
            auto m = *it;
            //得到该帧数据的topic
            std::string topic = m.getTopic();

            /*For bag created by writer_example.cpp*/
            if (topic == "chatter")
            {
                //此处为消息头文件中的ConstPtr
                std_msgs::String::ConstPtr msgPtr = m.instantiate<std_msgs::String>();
                if (msgPtr != NULL)
                {
                    std_msgs::String msg = *msgPtr;
                    std::cout << "chatter: " << msg << std::endl;
                }
            }
            if (topic == "numbers")
            {
                std_msgs::Int32::ConstPtr msgPtr = m.instantiate<std_msgs::Int32>();
                if (msgPtr != NULL)
                {
                    std_msgs::Int32 msg = *msgPtr;
                    std::cout << "numbers: " << msg << std::endl;
                }
            }
            if (topic == "/camera/color/image_raw")
            {
                /*
                msg_types={
                    'livox_ros_driver/CustomMsg': 'e4d6829bdfe657cb6c21a746c86b21a6', 
                    'sensor_msgs/Image': '060021388200f6f0f447d0fcd9c64743', 
                    'sensor_msgs/Imu': '6a62c6daae103f4ff57a132d6f95cec2'}, 
                topics={
                    '/camera/color/image_raw': TopicTuple(msg_type='sensor_msgs/Image', message_count=1415, connections=1, frequency=29.98780269827765), 
                    '/livox/imu': TopicTuple(msg_type='sensor_msgs/Imu', message_count=9549, connections=1, frequency=53773.1282051282),
                    '/livox/lidar': TopicTuple(msg_type='livox_ros_driver/CustomMsg', message_count=472, connections=1, frequency=10.001130231792896)
                }
                */
                sensor_msgs::ImageConstPtr ImageMsg_Ptr = m.instantiate<sensor_msgs::Image>();
                //sensor_msgs::ImagePtr msg= cv_bridge::CvImage(std_msgs::Header(), "bgr8", src).toImageMsg();
                if (ImageMsg_Ptr != NULL)
                {
                    if (frames <= 0)
                    {
                        cv_bridge::CvImagePtr cv_ptr = cv_bridge::toCvCopy(ImageMsg_Ptr, sensor_msgs::image_encodings::BGR8);
                        cv::Mat image = cv_ptr->image;
                        std::ostringstream oss;
                        oss << "./mid/real_sense_images/" << frames <<".jpg";
                        cv::imwrite(oss.str(), image);
                    }
                }
            }
            if (topic == "/livox/lidar")
            {
                wjc_pk::CustomMsg::ConstPtr CustomMsg_Ptr = m.instantiate<wjc_pk::CustomMsg>();
                if (CustomMsg_Ptr != NULL)
                {
                    if (frames <= 1000)
                    { /*a number limitation of records for debug*/

                        pcl::PointCloud<pcl::PointXYZI> pcl_cloud;     // pcl cloud format buffer
                        pcl::PointCloud<pcl::PointXYZI> dif_pcl_cloud; // difference of pcl cloud

                        pcl::PointCloud<pcl::PointXYZI> template_pcl_cloud; // pcl cloud of marker template
                        sensor_msgs::PointCloud2 output1, output2, output3; // sensor format buffer, CustomMsg_Ptr.points[] is Custom format buffer

                        /*After fix the variable "frames", it can extract information from a Custom_Msg.*/
                        //CustomMsg_interpreter(CustomMsg_Ptr);
                        /*Get cloud difference*/
                        dif_pcl_cloud = difference_pcl_cloud(CustomMsg_Ptr);
                        /*Convert the CustomMsg to pcl cloud.*/
                        Custom_Msg2pcl_cloud(CustomMsg_Ptr, pcl_cloud);

                        std::cout << "debug 1" << std::endl;

                        /*marker template segmentation code*/
                        if (pcl_cloud.size() > 0)
                        {
                            Eigen::VectorXf modelParas = detect_3d_circle(pcl_cloud.makeShared());
                            std::cout << "debug 2" << std::endl;
                            template_pcl_cloud = *draw_circle_template(modelParas);
                            std::cout << "debug 4" << std::endl;
                        }

                        std::cout << "debug 3" << std::endl;

                        /*visualize as grayscale*/
                        std::vector<my_point> my_points(pcl_cloud.size());
                        for (int i = 0; i < pcl_cloud.size(); i++)
                            my_points[i].init_by_PointXYZI(pcl_cloud.points[i]);
                        save_2d_grayscale(my_points, frames);
                        std::cout << "debug 4" << std::endl;

                        /*Convert the pcl cloud to ROS message.*/
                        std::cout << "pcl cloud size=" << pcl_cloud.size() << endl;
                        pcl::toROSMsg(pcl_cloud, output1);
                        pcl::toROSMsg(template_pcl_cloud, output2);
                        pcl::toROSMsg(dif_pcl_cloud, output3);

                        /*display frame by frame*/
                        output1.header.frame_id = "odom";
                        output2.header.frame_id = "odom";
                        output3.header.frame_id = "odom";
                        pcl_pub.publish(output1);
                        marker_pub.publish(output2);
                        dif_1_pub.publish(output3);
                        ros::spinOnce();
                        loop_rate.sleep();
                    }
                }
            }
            frames++;
        }
    }
    std::cout << "Totally " << frames << " frames" << std::endl;
    bag.close();
    return 0;
}

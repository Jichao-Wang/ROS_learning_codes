#include <iostream>
#include <typeinfo>
#include <vector>
#include <math.h>
#include <algorithm>

#include "ros/ros.h"
#include <rosbag/bag.h>
#include <rosbag/view.h>

#include <std_msgs/Int32.h>
#include <std_msgs/String.h>
#include <sensor_msgs/PointCloud2.h>
#include <wjc_pk/CustomMsg.h>
#include <wjc_pk/CustomPoint.h>

#include <pcl/io/pcd_io.h>
#include <pcl/point_types.h>
#include <pcl/surface/3rdparty/poisson4/geometry.h>
#include <pcl_conversions/pcl_conversions.h>
#include <pcl/sample_consensus/sac_model_circle3d.h>
#include <pcl/sample_consensus/ransac.h>
#include <pcl/segmentation/progressive_morphological_filter.h>

#include <opencv2/opencv.hpp>  

#include <boost/foreach.hpp>

#include "../include/abc.h"

#define foreach BOOST_FOREACH
#define Pi acos(-1)
#define livox_line_number 6 /*index of them are 0-5*/

void CustomMsg_interpreter(wjc_pk::CustomMsg::ConstPtr &CustomMsg_Ptr){
    /*display messages of a bag generated by lidar*/
    /*format of CustomMsg
    # Livox publish pointcloud msg format.
    Header header             # ROS standard message header
    uint64 timebase           # The time of first point
    uint32 point_num          # Total number of pointclouds
    uint8  lidar_id           # Lidar device id number
    uint8[3]  rsvd            # Reserved use
    CustomPoint[] points      # Pointcloud data
    */
    if(CustomMsg_Ptr!= NULL){
        /*output CustomMsg info*/
        std::cout<<"Header: "<< CustomMsg_Ptr->header.frame_id<<"\n"
            <<"Header Timestamp: "<<CustomMsg_Ptr->header.stamp<<"\n"
            <<"timebase: "<<CustomMsg_Ptr->timebase<<"\n"
            <<"point number: "<<CustomMsg_Ptr->point_num<<"\n"
            <<"LiDAR ID: "<<CustomMsg_Ptr->lidar_id<<std::endl;
            
        /*output vector of pointcloud*/
        //std::cout<<"vector type:"<<typeid(CustomMsg_Ptr->points).name()<<" point type"<<typeid(CustomMsg_Ptr->points[24000-1]).name()<<std::endl; //print data type of point cloud vector and point cloud.
        std::cout<<"point vector size: "<<CustomMsg_Ptr->points.size()<<"\n\n";
        for(int i=0;i<=1;i++){
            // ******it should be i<CustomMsg_Ptr->points.size()
            std::cout<<CustomMsg_Ptr->points[i]<<std::endl; //number of pointcloud in each vector is included in the previous info
        }
        std::cout<<CustomMsg_Ptr->points[24000-1]<<std::endl; //number of pointcloud in each vector is included in the previous info
        //std::cout<<CustomMsg_Ptr->points[0].x;  // the other method to display coordinate
    }
    else{
        std::cout<<"empty pointer"<<std::endl;
    }
}


void Custom_Msg2pcl_cloud(wjc_pk::CustomMsg::ConstPtr &CustomMsg_Ptr, pcl::PointCloud<pcl::PointXYZI>& pcl_cloud){
    pcl_cloud.points.resize(0);
    for(int i=0; i<CustomMsg_Ptr->points.size(); i++){
        /*dropout error points*/
        if(CustomMsg_Ptr->points[i].x-0>=0.00001&&CustomMsg_Ptr->points[i].y-0<=0.00001)
            continue;
        /*copy to pcl format*/
        pcl::PointXYZI mid_point;
        mid_point.x=CustomMsg_Ptr->points[i].x;
        mid_point.y=CustomMsg_Ptr->points[i].y;
        mid_point.z=CustomMsg_Ptr->points[i].z;
        mid_point.intensity=CustomMsg_Ptr->points[i].reflectivity;
        pcl_cloud.push_back(mid_point);
    }
    //std::cout<<"Custom_cloud:\n"<<CustomMsg_Ptr->points[0]<<"\n";
    //std::cout<<"pcl_cloud:"<<pcl_cloud.points[0]<<"\n";
    //std::cout<<pcl_cloud.points.size()<<std::endl;
}


Eigen::VectorXf detect_3d_circle(pcl::PointCloud<pcl::PointXYZI>::Ptr pcl_cloud){
    Eigen::VectorXf modelParas;
    /*3D circle extraction*/
    std::vector<int> inliersCircle3D;
    pcl::SampleConsensusModelCircle3D<pcl::PointXYZI>::Ptr model_circle3D(new pcl::SampleConsensusModelCircle3D<pcl::PointXYZI>(pcl_cloud));
    model_circle3D->setRadiusLimits(0.065,0.07); /*contraint of radius*/
    pcl::RandomSampleConsensus<pcl::PointXYZI> ransac(model_circle3D);
    /*contraint of thickness*/
    ransac.setDistanceThreshold(.01);
    //ransac.setDistanceThreshold(.05); 
    ransac.computeModel();
    ransac.getInliers(inliersCircle3D);
    ransac.getModelCoefficients(modelParas);
    //std::cout<<modelParas[3]<<" ";
    return modelParas;
}


pcl::PointCloud<pcl::PointXYZI>::Ptr draw_circle_template(Eigen::VectorXf modelParas){
    //std::cout <<"center x,y,z; R; vector\n"<<modelParas<< "\n";
    pcl::PointXYZ planeNormal(modelParas[0],modelParas[1],modelParas[2]);
    double R=modelParas[3];
    pcl::PointXYZ centerPoint(modelParas[4],modelParas[5],modelParas[6]);

	double nx = planeNormal.x, ny = planeNormal.y, nz = planeNormal.z;
	double cx = centerPoint.x, cy = centerPoint.y, cz = centerPoint.z;
	double r = R;
 
	double ux = ny, uy = -nx, uz = 0;
	double vx = nx*nz,
		vy = ny*nz,
		vz = -nx*nx - ny*ny;
 
	double sqrtU = sqrt(ux*ux + uy*uy + uz*uz);
	double sqrtV = sqrt(vx*vx + vy*vy + vz*vz);
 
	double ux_ = (1 / sqrtU)*ux;
	double uy_ = (1 / sqrtU)*uy;
	double uz_ = (1 / sqrtU)*uz;
 
	double vx_ = (1 / sqrtV)*vx;
	double vy_ = (1 / sqrtV)*vy;
	double vz_ = (1 / sqrtV)*vz;
 
	double xi, yi, zi;
	double t = 0;
	double angle = (t / 180.0)*Pi;
	vector<double> x, y, z;
 
	while (t < 360.0){
		xi = cx + r*(ux_*cos(angle) + vx_*sin(angle));
		yi = cy + r*(uy_*cos(angle) + vy_*sin(angle));
		zi = cz + r*(uz_*cos(angle) + vz_*sin(angle));
		x.push_back(xi);
		y.push_back(yi);
		z.push_back(zi);
 
		t = t + 1;
		angle = (t / 180.0)*Pi;
	}
	pcl::PointCloud<pcl::PointXYZI>::Ptr theroyCirclePoints(new pcl::PointCloud<pcl::PointXYZI>);

	theroyCirclePoints->resize(x.size());
	for (int i = 0; i < x.size(); i++){
		(*theroyCirclePoints)[i].x = x[i];
		(*theroyCirclePoints)[i].y = y[i];
		(*theroyCirclePoints)[i].z = z[i];
        (*theroyCirclePoints)[i].intensity = 255;
	}
    return theroyCirclePoints;
}


pcl::PointCloud<pcl::PointXYZI> difference_pcl_cloud(wjc_pk::CustomMsg::ConstPtr &CustomMsg_Ptr){
    pcl::PointCloud<pcl::PointXYZI> dif_pcl_cloud;
    if(CustomMsg_Ptr!= NULL){
        for(int i = 0;i < CustomMsg_Ptr->points.size()-1; i++){
            //if (CustomMsg_Ptr->points[i].line==0){
                pcl::PointXYZI mid;
                mid.x=CustomMsg_Ptr->points[i].x;
                mid.y=CustomMsg_Ptr->points[i].y;
                mid.z=CustomMsg_Ptr->points[i].z;
                mid.intensity=CustomMsg_Ptr->points[i+1].reflectivity-CustomMsg_Ptr->points[i].reflectivity;
                //std::cout<<mid.intensity<<" ";
                /*find edge points.*/
                if(abs(mid.intensity)>=20)
                    dif_pcl_cloud.push_back(mid);
            //}
        }
    }
    else{
        std::cout<<"empty pointer"<<std::endl;
    }
    return dif_pcl_cloud;
}


int main(int argc, char **argv){
    /*initialize the node*/
    ros::init(argc, argv, "writer_example");
    ros::NodeHandle n;
    ros::Publisher pcl_pub = n.advertise<sensor_msgs::PointCloud2> ("wjc_pcl_output", 100);
    ros::Publisher marker_pub = n.advertise<sensor_msgs::PointCloud2> ("wjc_marker", 100);
    ros::Publisher dif_1_pub = n.advertise<sensor_msgs::PointCloud2> ("difference_1", 100);
    
    /*打开bag文件*/
    rosbag::Bag bag;
    bag.open("crc_short2.bag", rosbag::bagmode::Read); //"Test2crc.bag"

    /*设置需要遍历的topic*/
    std::vector<std::string> topics; 
    topics.push_back(std::string("/livox/lidar"));
    topics.push_back(std::string("chatter"));
    topics.push_back(std::string("numbers"));

    rosbag::View view(bag, rosbag::TopicQuery(topics));
    //rosbag::View view_all(view); //读取全部topic
    //使用迭代器的方式遍历,注意：每一个迭代器为一帧数据
    rosbag::View::iterator it = view.begin();

    int frames=0; ros::Rate loop_rate(10);
    while (ros::ok()){
        for(; it != view.end(); ++it){
            //std::cout<<"----------------------------------"<<std::endl; /*each line represents a new scan part*/
            auto m = *it;
            //得到该帧数据的topic
            std::string topic = m.getTopic();

            /*For bag created by writer_example.cpp*/
            if(topic == "chatter"){
                //此处为消息头文件中的ConstPtr
                std_msgs::String::ConstPtr msgPtr = m.instantiate<std_msgs::String>();
                if(msgPtr != NULL){
                    std_msgs::String  msg = *msgPtr;
                    std::cout<<"chatter: "<<msg<<std::endl;
                }
            }
            if(topic == "numbers"){
                std_msgs::Int32::ConstPtr msgPtr = m.instantiate<std_msgs::Int32>();
                if(msgPtr != NULL){
                    std_msgs::Int32  msg = *msgPtr;
                    std::cout<<"numbers: "<<msg<<std::endl;
                }
            }
            if(topic == "/livox/lidar"){
                wjc_pk::CustomMsg::ConstPtr CustomMsg_Ptr = m.instantiate<wjc_pk::CustomMsg>();
                if(CustomMsg_Ptr!= NULL){
                    if(frames<=1000){/*a number limitation of records for debug*/

                        pcl::PointCloud<pcl::PointXYZI> pcl_cloud; // pcl cloud format buffer
                        pcl::PointCloud<pcl::PointXYZI> dif_pcl_cloud; // difference of pcl cloud
                        
                        pcl::PointCloud<pcl::PointXYZI> template_pcl_cloud; // pcl cloud of marker template
                        sensor_msgs::PointCloud2 output1, output2, output3;  // sensor format buffer, CustomMsg_Ptr.points[] is Custom format buffer

                        /*After fix the variable "frames", it can extract information from a Custom_Msg.*/
                        CustomMsg_interpreter(CustomMsg_Ptr);
                        /*Get cloud difference*/
                        dif_pcl_cloud = difference_pcl_cloud(CustomMsg_Ptr);
                        /*Convert the CustomMsg to pcl cloud.*/
                        Custom_Msg2pcl_cloud(CustomMsg_Ptr, pcl_cloud);
            
                        /*marker template segmentation code*/
                        if(pcl_cloud.size()>0){
                            Eigen::VectorXf modelParas = detect_3d_circle(pcl_cloud.makeShared());
                            template_pcl_cloud = *draw_circle_template(modelParas);
                        }

                        /*visualize as grayscale*/
                        std::vector<my_point> my_points(pcl_cloud.size());
                        for(int i=0;i<pcl_cloud.size();i++)my_points[i].init_by_PointXYZI(pcl_cloud.points[i]);
                        save_2d_grayscale(my_points, frames);

                        /*Convert the pcl cloud to ROS message.*/
                        std::cout<<"pcl cloud size="<<pcl_cloud.size()<<endl;
                        pcl::toROSMsg(pcl_cloud, output1);
                        pcl::toROSMsg(template_pcl_cloud, output2);
                        pcl::toROSMsg(dif_pcl_cloud, output3);

                        /*display frame by frame*/
                        output1.header.frame_id = "odom";
                        output2.header.frame_id = "odom";
                        output3.header.frame_id = "odom";
                        pcl_pub.publish(output1);
                        marker_pub.publish(output2);
                        dif_1_pub.publish(output3);
                        ros::spinOnce();
                        loop_rate.sleep();
                    }
                    frames++;
                }
            }
        }
    }
    std::cout<<"Totally "<<frames<<" frames"<<std::endl;
    bag.close();
    return 0;
}
